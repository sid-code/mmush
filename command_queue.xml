<?xml version="1.0" encoding="iso-8859-1"?>

<!DOCTYPE muclient>
<!-- Saved on Saturday, October 24, 2015, 7:23 PM -->
<!-- MuClient version 4.98 -->

<!-- Plugin "ext_quest_mon" generated by Plugin Wizard -->

<muclient>
<plugin
   name="command_queue"
   author="Morn"
   id="b1ccbcd452d33de54e64581f"
   language="Lua"
   purpose="Lets you stack commands into a client side queue so you're not lagged on the server"
   save_state="y"
   date_written="2016-01-27 19:21:22"
   requires="4.80"
   version="1.0"
   >

</plugin>

<aliases>
  <alias
    name="cqueue_flush"
    match="^cq flush$"
    enabled="y"
    script="cqueue_flush"
    sequence="99"
    regexp="y"
  />
  <alias
    name="cqueue_flush_special"
    match="^cqs (?<queue_name>\w+) flush$"
    enabled="y"
    script="cqueue_flush"
    sequence="99"
    regexp="y"
  />

  <alias
    name="cqueue_add"
    match="^cq (?<command>.+)$"
    enabled="y"
    script="cqueue_add"
    sequence="100"
    regexp="y"
  />

  <alias
    name="cqueue_add_special"
    match="^cqs (?<queue_name>\w+) (?<command>.+)$"
    enabled="y"
    script="cqueue_add"
    sequence="100"
    regexp="y"
  />

  <alias
    name="cqueue_add_multiple"
    match="^cqn (?<count>\d+) (?<command>.+)$"
    enabled="y"
    script="cqueue_add_multiple"
    sequence="100"
    regexp="y"
  />

  <alias
    name="cqueue_add_multiple_special"
    match="^cqns (?<queue_name>\w+) (?<count>\d+) (?<command>.+)$"
    enabled="y"
    script="cqueue_add_multiple"
    sequence="100"
    regexp="y"
  />

  <alias
    name="cqueue_verbose"
    match="cqc verbose (?<state>off|on)"
    enabled="y"
    script="cqueue_verbose"
    sequence="100"
    regexp="y"
  />
</aliases>

<triggers>

  <trigger
    name="unqueue"
    match="{unqueue *}"
    sequence="100"
    enabled="y"
    send_to="12"
    script="cqueue_unqueue"
  />

</triggers>

<!--  Get our standard constants -->

<include name="constants.lua"/>
<script>
<![CDATA[

local fighting = false
local char_state = -1
local last_state = -1

-- The queue is just an array of commands, first element is the next to be sent
local cqueue = {}
cqueue.combat = true

-- all the queues
local queues = {
  combat = cqueue
}

function OnPluginBroadcast (msg, id, name, text)
  if (id == '3e7dedbe37e44942dd46d264') then
    if text == "char.status" then
      res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.status")
      luastmt = "gmcpdata = " .. gmcparg

      assert (loadstring (luastmt or "")) ()

      char_state = gmcpdata.state
      if last_state == "8" and char_state == "3" then
        cqueue_note("Combat over -- flushing queue")
        cqueue_flush("onpluginbroadcast", "", {})
        Simulate("{/combat}")
      end
      last_state = char_state
    end
  end
end

-- https://www.gammon.com.au/forum/bbshowpost.php?bbsubject_id=9739
function ExecuteNoEcho (whatever)
  local original_echo_setting = GetOption("display_my_input")
  SetOption ("display_my_input", 0)
  Execute (whatever)
  SetOption ("display_my_input", original_echo_setting)
end

function cqueue_note(msg)
  ColourNote("black", "white", msg)
end

function cqueue_verbose(name, line, wildcards)
  local state = wildcards.state
  SetVariable("cqueue_verbose", state)
  cqueue_note("cqueue verbose turned " .. state)
end

function cqueue_clear()
  cqueue = {}
end

-- remove and send the first command
function cqueue_unqueue(name, line, wildcards)
  local queue_name = wildcards[1]
  local queue = queues[queue_name]
  if queue == nil then
    cqueue_note("Warning: no queue named " .. queue_name)
    return
  end

  local command = table.remove(queue, 1)
  if command ~= nil then
    ExecuteNoEcho(command)

    if GetVariable("cqueue_verbose") == "on" then
      cqueue_note("command_queue: " .. command .. ", " .. tostring(#queue) .. " left.")
    end

    if queue.combat then
      SendNoEcho("echo {unqueue " .. queue_name .. "}")
    end
  end
end

function cqueue_add_raw(queue_name, command, count)
  local queue = queues[queue_name]
  if queue == nil then
    queues[queue_name] = {}
    queue = queues[queue_name]
    cqueue_note("Created new queue named " .. queue_name)
  end

  local i = 0
  while i < tonumber(count) do
    table.insert(queue, command)
    i = i + 1
  end

  if GetVariable("cqueue_verbose") == "on" then
    cqueue_note("Queued up " .. count .. "x: " .. command)
  end

  if #queue == count and queue.combat then
    SendNoEcho("echo {unqueue " .. queue_name .. "}")
    SendNoEcho("echo {unqueue " .. queue_name .. "}")
  end
end

function cqueue_add(name, line, wildcards)
  local command = wildcards.command
  local count = 1
  local queue_name = wildcards.queue_name or "combat"

  cqueue_add_raw(queue_name, command, count)
end

function cqueue_add_multiple(name, line, wildcards)
  local command = wildcards.command
  local count = tonumber(wildcards.count)
  local queue_name = wildcards.queue_name or "combat"

  cqueue_add_raw(queue_name, command, count)
end

function cqueue_flush(name, line, wildcards)
  local queue_name = wildcards.queue_name or "combat"
  local queue = queues[queue_name]
  if queue == nil then
    cqueue_note("Warning: no queue named " .. queue_name)
    return
  end

  while #queue > 0 do
    table.remove(queue, 1)
  end

  cqueue_note("Command queue '" .. queue_name .. "' flushed")
  
end


]]>
</script>

</muclient>
