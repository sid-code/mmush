<?xml version="1.01" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Saturday, June 12, 2012, 9:13 PM -->
<!-- MuClient version 4.77 -->

<!-- Plugin "MazeSolver" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Trachx_MazeSolver"
   author="Trachx"
   id="e77aaf477d87067b8ed749f4"
   language="Lua"
   purpose="Maze solving utility"
   save_state="y"
   date_written="2012-06-11 11:12:13"
   requires="4.77"
   version="1.01"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->

<!--  Aliases  -->

<aliases>
  <alias
   match="#maze"
   script="StartSolver"
   enabled="y"
   group="Trachx_MazeSolver"
   send_to="12"
   sequence="10"
  >
  </alias>
</aliases>

<aliases>
  <alias
   match="#maze_repop"
   script="repopsimulate"
   enabled="y"
   group="Trachx_MazeSolver"
   send_to="12"
   sequence="10"
  >
  </alias>
</aliases>



<aliases>
  <alias
   match="#maze_help"
   script="MazeShowHelp"
   enabled="y"
   group="Trachx_MazeSolver"
   send_to="12"
   sequence="10"
  >
  </alias>
</aliases>


<aliases>
  <alias
   match="#maze_next"
   script="MazeNextRoom"
   enabled="y"
   group="Trachx_MazeSolver"
   send_to="12"
   sequence="10"
  >
  </alias>
</aliases>

<aliases>
  <alias
   match="^(?<cmd>#maze_next_dir) ?(?<direction>[neswdu])?$"
   script="MazeNextRoom_dir"
   enabled="y"
   group="Trachx_MazeSolver"
   send_to="12"
   sequence="10"
   regexp="y"
  >
  </alias>
</aliases>


<aliases>

  <alias
   match="^(?<cmd>#maze_goto) ?(?<roomid>[0-9]+)?$"
   script="MazeGotoRoom"
   enabled="y"
   group="Trachx_MazeSolver"
   send_to="12"
   sequence="10"
   regexp="y"
  >
  </alias>
</aliases>


<aliases>
  <alias
   match="#maze_dump"
   script="MazeDump"
   enabled="y"
   group="Trachx_MazeSolver"
   send_to="12"
   sequence="10"
  >
  </alias>
</aliases>

<aliases>
  <alias
   match="#maze_dump_db"
   script="MazeDumpDB"
   enabled="y"
   group="Trachx_MazeSolver"
   send_to="12"
   sequence="10"
  >
  </alias>
</aliases>

<script>
<![CDATA[


require("gmcphelper")


ms_basearea = ""

ms_room_table = {}

lastroom = ""
lastmove = ""
enablemap = false


function MazeNextRoom_dir (name, line, wildcards)
	dir = wildcards.direction
        local tt = gmcp("room.info")

	ColourNote( "black","#F5F5DC", "Try to go " .. dir)
	lastroom = tt.num
	lastmove = dir
	enablemap = true
	Send(dir)
end

function MazeNextRoom ()
        local tt = gmcp("room.info")
	if tt['zone'] then
		thisroom = tt.num

		done = false

-- find this room and check whethere there are unmapped exits
		roomInTable = false
		for i,room in ipairs(ms_room_table) do 
			if (room.num == thisroom and room.area == tt.zone) then
				for k,v in pairs(room.exits) do 
					if v == "-1" then					
						lastroom = thisroom
						lastmove = k
						enablemap = true
						Send(k)
						done = true
						break
					end
				end
				roomInTable = true
			end -- if this room
		end -- for 

-- there were no unmapped exits in current room - move to next room with unmapped exits
		if roomInTable == false then
			AddRoom(tt)
		elseif done == false then			
			ColourNote( "black","#F5F5DC", "Room " .. thisroom .. " is fully mapped, trying to go to first unmapped room")


			for i,room in ipairs(ms_room_table) do 
				if (room.area == tt.zone) then
					for k,v in pairs(room.exits) do 
						if v == "-1" then		
							path = FindPathFromTo(thisroom, room.num)			
							ColourNote( "black","#F5F5DC", "Trying " .. room.num .. " path " .. path)
							if not (path == "") then
								Send("run " .. path)
								done = true
								break
							end
						end
					end -- for exits in room
				end
				if done == true then break end
			end -- for
		end 
	end -- tt['zone']
		
end

function MazeDumpDB()
	require("sqlite3")
	local db_path = GetInfo(66) .. "mazes.db"
	local db = assert(sqlite3.open(db_path))
	
	assert(db:execute([[
CREATE TABLE IF NOT EXISTS mexits (fromuid TEXT, touid TEXT, UNIQUE(fromuid, touid)) ;
]]))

	for i, room in ipairs(ms_room_table) do
		-- direction doesn't matter
		for _, touid in pairs(room.exits) do
			assert(db:execute(
				       string.format("INSERT INTO mexits VALUES ('%s', '%s')",
						     room.num, touid)))
		end
	end
end

function MazeDump ()
	ColourNote( "black","#F5F5DC", "Rooms in maze solver tables:")		
	for i,room in ipairs(ms_room_table) do 
		x = "Room: " .. room.num .. "  " .. room.area .. ", " .. room.name 
		for k,v in pairs(room.exits) do 
			x = x .. "   " .. k .. "->" .. v
		end

		ColourNote( "black","#F5F5DC", x)		
	end
end


function MazeShowHelp() 

	ColourNote("black","#F5F5DC"," " .. "---------------------------------------------------------------------------- ")
	ColourNote("black","#F5F5DC"," " .. "Maze solver by Trachx *experimental*                                ver 1.01 ")
	ColourNote("black","#F5F5DC"," " .. "---------------------------------------------------------------------------- ")
	ColourNote("black","#F5F5DC"," " .. "  #maze_help       - this info                                               ")
	ColourNote("black","#F5F5DC"," " .. "  #maze            - clear Maze Solver tables                                ")
	ColourNote("black","#F5F5DC"," " .. "  #maze_dump       - display rooms visited so far and exits                  ")
	ColourNote("black","#F5F5DC"," " .. "  #maze_next       - try to go to next unmapped room                         ")
	ColourNote("black","#F5F5DC"," " .. "  #maze_goto <num> - go to room number <num>, use #maze_dump to get <num>    ")
	ColourNote("black","#F5F5DC"," " .. "  #maze_next_dir <e|s|w|u|d|n> - go into specified direction instead next    ")
	ColourNote("black","#F5F5DC"," " .. "  How to solve maze: type #maze in first maze room, then use #maze_next      ")
	ColourNote("black","#F5F5DC"," " .. "  till you map whole maze or use #maze_next_dir if you want to map desired   ")
	ColourNote("black","#F5F5DC"," " .. "  exit. Sometimes you need to use #maze_goto <room> if you won't be taken    ")
	ColourNote("black","#F5F5DC"," " .. "  there automatically. Best start just after repop to have enough time to    ")
	ColourNote("black","#F5F5DC"," " .. "  map maze. While you stay in area repops are detected and clear maze table. ")
	ColourNote("black","#F5F5DC"," " .. "---------------------------------------------------------------------------- ")
    
end

function StartSolver ()
        local tt = gmcp("room.info")
	if tt['zone'] then
		ms_room_table = {}
		AddRoom(tt)
	end
end

function AddRoom(tt)
	ms_basearea = tt.zone
	lastroom = tt.num
	exits = tt.exits
	ColourNote( "black","#F5F5DC", "New room in area = " .. ms_basearea .. ", current room: " .. lastroom .. " details: " .. tt.details)

	for k,v in pairs(exits) do
		ColourNote( "black","#F5F5DC", "area = " .. k .. " v = " .. v)
	end

	troom = {}
	troom.num = tt.num
	troom.exits = exits
	troom.area = tt.zone
	troom.name = tt.name

	table.insert(ms_room_table, troom)
end

function repopsimulate()




	return ""
end

function OnPluginBroadcast (msg, id, name, text)

-- if repop occured - remove rooms from repop area
  if (id == '3e7dedbe37e44942dd46d264' and text == 'comm.repop') then
        local tt = gmcp("room.info")
	removed = false
	if tt['zone'] then
		for i=#ms_room_table,1,-1 do
			if ms_room_table[i].area == tt.zone then
				table.remove(ms_room_table, i)
				removed = true
			end
		end

		if removed then
			ColourNote( "black","#F5F5DC", "MazeSolver: Some rooms were removed due to repop in area " .. tt.zone)
		end
	end
  end


  if (id == '3e7dedbe37e44942dd46d264' and text == 'room.info' and enablemap) then
        local tt = gmcp("room.info")
	thisroom = tt.num

	done = false
	enablemap = false
	roomIsMapped = false

	for i,room in ipairs(ms_room_table) do 
-- add exit in previous room
		if (room.num == lastroom) then			
			room.exits[lastmove] = thisroom
		end
-- check whether curren room is in table
		if (room.num == thisroom) then			
			roomIsMapped = true
		end
	end

	if roomIsMapped == false then
		AddRoom(tt)
	end
  end

end

visited = ""


function OnPluginInstall()
	MazeShowHelp()
end

function MazeGotoRoom (name, line, wildcards)
	ColourNote( "black","#F5F5DC", wildcards.roomid)
	visited = "-1"
        local tt = gmcp("room.info")
	if tt['zone'] then
		thisroom = tt.num
		if thisroom == wildcards.roomid then
			ColourNote( "black","#F5F5DC", "But you are in room id : " .. thisroom)
			return
		end

		path = FindPathFromTo(thisroom, wildcards.roomid)
		ColourNote( "black","#F5F5DC", "Executing path : " .. path)
		if not (path == "") then
			Send("run " .. path)
		end
	end
end

function FindPathFromTo (from, to)
	visited = visited .. "," .. from

	local path = ""

	for i,room in ipairs(ms_room_table) do 
-- find room "from" and check its exits
		if room.num == from then	
-- first check whether one of exits leads directly to required room
			for k,v in pairs(room.exits) do 
				if v == to then
					return k
				end
			end

-- check first room not visited so far
			for k,v in pairs(room.exits) do 
				if not string.find(visited, v) then
					path = FindPathFromTo (v, to)
					ColourNote( "black","#F5F5DC", "Path returned : " .. path)
					if not (path == "") then 
						return k .. path
					end
				end
			end

			break
		end -- num == from
	end -- for i,room

	return ""

end



]]>
</script>

</muclient>
